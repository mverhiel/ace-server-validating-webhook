###############################################################################
# Pipeline that builds the ACE admission webhook.
#
# Parameters
# REGISTRY_SERVICE_CONNECTION: An AzDo service connection to your container
#                     registry. AzDo projects at MetLife should have a service
#                     connection named "DTR" for DTR, but you can also create
#                     your own Service Connection of type Docker to another
#                     container registry such as ACR.
# IMAGE_REPOSITORY:   The repository in the container registry to push container
#                     images to. DTR repositories must also include the
#                     organization name. For example: myorg/myrepository
#                     For DTR, the repository must exist before the container
#                     image can be pushed to it. For ACR, the repository will be
#                     created when the first container is pushed to it.
###############################################################################
parameters:
- name: REGISTRY_SERVICE_CONNECTION
  displayName: "Container Registry Service Connection"
  type: string
  default: "MetLife DTR"
- name: IMAGE_REPOSITORY
  type: string
  displayName: "Name of image repository"
  default: "13574-ace/ace-webhook-validation"

trigger:
- none

# Use MetLife build machines that have access to docker commands
pool:
    name: Linux
    demands:
    - docker

workspace:
  clean: all

steps:

# https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/go-tool-v0?view=azure-pipelines
- task: GoTool@0
  name: get_go_tools
  displayName: "Get Go tools"
  inputs:
    version: '1.18' # string. Required. Version. Default: 1.10.

# https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/go-v0?view=azure-pipelines
- task: Go@0
  name: build_webhook
  displayName: "Build Webhook"
  inputs:
    command: build
    workingDirectory: $(System.DefaultWorkingDirectory)
    arguments: -o $(System.DefaultWorkingDirectory)/bin/webhook

- task: PowerShell@2
  name: debug_build
  displayName: "Output build debug info"
  inputs:
    targetType: 'inline'
    failOnStderr: true
    script: |
      Write-Host "[debug] $(System.DefaultWorkingDirectory)/bin contents"
      Get-ChildItem -Path $(System.DefaultWorkingDirectory)/bin/webhook -Recurse -File

# Build the Docker container for the application and push to the container registry
# Default tag is $(Build.BuildId)
- task: Docker@2
  name: create_and_push_container
  displayName: "Create and push container"
  inputs:
    # Refer to build variables: $(VAR_NAME)
    # Update containerRegistry to your registry service connection.
    containerRegistry: '${{parameters.REGISTRY_SERVICE_CONNECTION}}'
    repository: '${{parameters.IMAGE_REPOSITORY}}'
    command: 'buildAndPush'
    Dockerfile: '**/Dockerfile'
    tags: |
      $(Build.BuildId)

# Don't leave cruft (old images) on the build agent. The layers for an image
# won't be deleted until ALL references (tags) to it are removed. That's why
# we have to remove the new image we created and the base image.
- task: PowerShell@2
  name: cleanup
  condition: always()
  displayName: "Cleanup local container registry"
  inputs:
    targetType: 'inline'
    script: |
      # Specify the tag that was used for the new container after the :!
      $grep = "${{parameters.IMAGE_REPOSITORY}}:$(Build.BuildId)"
      $tag = docker image ls --format "{{.Repository}}:{{.Tag}}" | grep $grep

      Write-Host "[debug] Removing image $tag"
      docker image remove $tag

      Write-Host "[debug] Removing base image registry.access.redhat.com/ubi8/ubi-minimal:latest"
      docker image remove registry.access.redhat.com/ubi8/ubi-minimal:latest
